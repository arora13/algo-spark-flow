{
  "bubble_sort": [
    {
      "id": 1,
      "title": "Bubble Sort Basic Algorithm",
      "difficulty": "Easy",
      "description": "Given an array of unsorted numbers, implement a basic bubble sorting algorithm which takes that input and orders the numbers from lowest to highest using that implementation",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 1000).",
      "output_desc": "A new array of numbers sorted from lowest to highest using bubble sort",
      "examples": [
        {
          "input": [6, 3, 2, 5, 9],
          "output": [2, 3, 5, 6, 9]
        },
        {
          "input": [75, 89, 35, 12, 9, 100],
          "output": [9, 12, 35, 75, 89, 100]
        }
      ],
      "constraints": [
        "The sorting must be done using bubble sort. Other sorting implementations will not suffice"
      ]
    },
    {
      "id": 2,
      "title": "Count swaps in Bubble Sort",
      "difficulty": "Easy",
      "description": "Given an array of integers, implement a bubble sort algorithm which not only sorts the integers in ascending order, but also counts the amount of times a number was swapped during the sorting process. Return the number of swaps as an integer.",
      "input_desc": "An array of integers arr where 1 ≤ len(arr) ≤ 1000.",
      "output_desc": "An integer representing the total number of swaps the bubble sort algorithm performs to sort the array.",
      "examples": [
        {
          "input": [6, 3, 2, 5, 9],
          "output": 4
        },
        {
          "input": [75, 89, 35, 12, 9, 100],
          "output": 9
        }
      ],
      "constraints": [
        "You must implement bubble sort manually; built-in sorting functions like sorted() or .sort() are not allowed.",
        "Count every swap between neighboring elements."
      ]
    },
    {
      "id": 3,
      "title": "Bubble Sort Strings",
      "difficulty": "Medium",
      "description": "Given an array of strings, implement a bubble sort algorithm which sorts the array in ascending alphabetical order. Return the sorted array.",
      "input_desc": "An array of strings arr, where 1 ≤ len(arr) ≤ 1000. Each string consists of lowercase or uppercase English letters.",
      "output_desc": "A new array representing the finished product after alphabetically sorting using a bubble_sort algorithm",
      "examples": [
        {
          "input": ["banana", "apple", "cherry"],
          "output": ["apple", "banana", "cherry"]
        },
        {
          "input": ["dog", "zebra", "cat", "ant", "hippo"],
          "output": ["ant", "cat", "dog", "hippo", "zebra"]
        }
      ],
      "constraints": [
        "You must implement bubble sort manually; built-in sorting functions like sorted() or .sort() are not allowed.",
        "When sorting make sure to know uppercase letters come before lowercase letters in ASCII order."
      ]
    },
    {
      "id": 4,
      "title": "Bubble Sort Iteration Counter",
      "difficulty": "Medium",
      "description": "Given an array of unsorted integers, implement a bubble sorting algorithm which sorts the array from lowest to highest. Instead of returning the sorted array, count the number of iterations taken to fully sort the array. An iteration is defined as one complete traversal of the array (from the first element to the last) where neighboring elements may be swapped.",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 1000).",
      "output_desc": "An integer representing the number of iterations taken to complete the bubble_sort process",
      "examples": [
        {
          "input": [6, 3, 2, 5, 9],
          "output": 3
        },
        {
          "input": [75, 89, 35, 12, 9, 100],
          "output": 5
        }
      ],
      "constraints": [
        "You must write bubble sort yourself; you cannot use built-in sorting functions like sorted() or .sort().",
        "If an iteration makes no swaps, count that as the last run-through, since the array is already sorted, and return the full count."
      ]
    },
    {
      "id": 5,
      "title": "Custom Bubble Sort",
      "difficulty": "Hard",
      "description": "Given an array of integers, implement a bubble sort algorithm with a single constraint. You can only swap neighboring elements just like a normal bubble sort algorithm; however, the left element has to be even. Return the sorted array according to this rule. If the array cannot be fully sorted due to the constraint, return the partially sorted array.",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 1000).",
      "output_desc": "An array of integers representing the array sorted as much as possible under the constraint.",
      "examples": [
        {
          "input": [4, 3, 2, 1, 9],
          "output": [3, 1, 4, 2, 9]
        },
        {
          "input": [68, 11, 46, 35, 28, 51],
          "output": [11, 35, 28, 46, 51, 68]
        }
      ],
      "constraints": [
        "You must implement bubble sort manually; built-in sorting functions like sorted() or .sort() are not allowed.",
        "Only swap neighboring elements if the left element is even.",
        "Stop iterating early if no swaps are possible in a full iteration."
      ]
    }
  ],
  "merge_sort": [
    {
      "id": 1,
      "title": "Merge Two Sorted Arrays",
      "difficulty": "Easy",
      "description": "Given two sorted arrays, merge them into one single sorted array in ascending order.",
      "input_desc": "Two arrays of numbers, arr1 and arr2, each sorted in ascending order. (1 ≤ len(arr1), len(arr2) ≤ 1000)",
      "output_desc": "A new array containing all elements from arr1 and arr2 in ascending order.",
      "examples": [
        {
          "input": [[1, 3, 5], [2, 4, 6]],
          "output": [1, 2, 3, 4, 5, 6]
        },
        {
          "input": [[10, 20], [5, 15, 25]],
          "output": [5, 10, 15, 20, 25]
        }
      ],
      "constraints": [
        "You must implement the merge process manually; using built-in sorting functions like sorted() or .sort() are not permitted",
        "The inputs are guaranteed to be sorted arrays"
      ]
    },
    {
      "id": 2,
      "title": "Recursive Maximum of an Array",
      "difficulty": "Easy",
      "description": "Given an array of integers, find the maximum value within the array using recursion. Loops and built-in functions like max() are not permitted.",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 1000).",
      "output_desc": "A single integer which represents the largest number in the given array",
      "examples": [
        {
          "input": [3, 1, 7, 4],
          "output": 7
        },
        {
          "input": [10, 2, 5, 8, 6],
          "output": 10
        }
      ],
      "constraints": [
        "You must implement the search process using recursion",
        "Using built-in functions like max() or loops are not permitted"
      ]
    },
    {
      "id": 3,
      "title": "Merge Sort Basic Algorithm",
      "difficulty": "Medium",
      "description": "Given an array of unsorted numbers, implement a basic merge sorting algorithm which takes that input and puts the integers in ascending order using the merge sort algorithm.",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 1000).",
      "output_desc": "A new array of numbers sorted from lowest to highest using merge sort",
      "examples": [
        {
          "input": [8, 3, 1, 7, 0, 10, 2],
          "output": [0, 1, 2, 3, 7, 8, 10]
        },
        {
          "input": [15, 9, 27, 6, 12],
          "output": [6, 9, 12, 15, 27]
        }
      ],
      "constraints": [
        "The sorting must be done using merge sort. Other sorting implementations will not suffice",
        "Built-in sorting functions like sorted() or .sort() are not allowed.",
        "Your solution must use a recursive divide-and-conquer approach"
      ]
    },
    {
      "id": 4,
      "title": "Count Inversions using Merge Sort",
      "difficulty": "Medium",
      "description": "Using elements of the Merge Sort algorithm, count the number of inversions found in the given array after recursively splitting it into halves. An inversion is defined as a pair of elements (arr[i], arr[j]) such that i < j and arr[i] > arr[j].",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 1000).",
      "output_desc": "An integer representing the total number of inversions in the array.",
      "examples": [
        {
          "input": [2, 4, 1, 3, 5],
          "output": 3
        },
        {
          "input": [5, 4, 3, 2, 1],
          "output": 10
        }
      ],
      "constraints": [
        "You may use recursion and the Merge Sort concept but do not implement the entire sort",
        "Aim for O(n log n) complexity using the merge idea.",
        "Built-in sorting functions like sorted() or .sort() are not allowed.",
        "Resource: https://www.geeksforgeeks.org/dsa/inversion-count-in-array-using-merge-sort/"
      ]
    },
    {
      "id": 5,
      "title": "Counting Reverse Pairs",
      "difficulty": "Hard",
      "description": "Given an array of integers, count the number of reverse pairs in the given array. A reverse pair is defined as a pair (i, j) where i < j and arr[i] > 2 * arr[j]. Implement a solution using a modified Merge Sort algorithm.",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 100000).",
      "output_desc": "An integer representing the total number of reverse pairs in the array.",
      "examples": [
        {
          "input": [1, 3, 2, 3, 1],
          "output": 2,
          "explanation": "The reverse pairs are (1, 4) and (3, 4)."
        },
        {
          "input": [2, 4, 3, 5, 1],
          "output": 3,
          "explanation": "The reverse pairs are (1, 4), (2, 4), and (3, 4)."
        }
      ],
      "constraints": [
        "You may use recursion and the Merge Sort concept but do not implement the entire sort",
        "Aim for O(n log n) complexity using the merge idea.",
        "Built-in sorting functions like sorted() or .sort() are not allowed.",
        "Only pairs where i < j are considered."
      ]
    }
  ]
}
