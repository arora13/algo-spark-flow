{
  "bubble_sort": [
    {
      "id": 1,
      "title": "Bubble Sort Basic Algorithm",
      "difficulty": "Easy",
      "description": "Given an array of unsorted numbers, implement a basic bubble sorting algorithm which takes that input and orders the numbers from lowest to highest using that implementation",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 1000).",
      "output_desc": "A new array of numbers sorted from lowest to highest using bubble sort",
      "examples": [
        {
          "input": [6, 3, 2, 5, 9],
          "output": [2, 3, 5, 6, 9]
        },
        {
          "input": [75, 89, 35, 12, 9, 100],
          "output": [9, 12, 35, 75, 89, 100]
        }
      ],
      "constraints": [
        "The sorting must be done using bubble sort. Other sorting implementations will not suffice"
      ]
    },
    {
      "id": 2,
      "title": "Count swaps in Bubble Sort",
      "difficulty": "Easy",
      "description": "Given an array of integers, implement a bubble sort algorithm which not only sorts the integers in ascending order, but also counts the amount of times a number was swapped during the sorting process. Return the number of swaps as an integer.",
      "input_desc": "An array of integers arr where 1 ≤ len(arr) ≤ 1000.",
      "output_desc": "An integer representing the total number of swaps the bubble sort algorithm performs to sort the array.",
      "examples": [
        {
          "input": [6, 3, 2, 5, 9],
          "output": 4
        },
        {
          "input": [75, 89, 35, 12, 9, 100],
          "output": 9
        }
      ],
      "constraints": [
        "You must implement bubble sort manually; built-in sorting functions like sorted() or .sort() are not allowed.",
        "Count every swap between neighboring elements."
      ]
    },
    {
      "id": 3,
      "title": "Bubble Sort Strings",
      "difficulty": "Medium",
      "description": "Given an array of strings, implement a bubble sort algorithm which sorts the array in ascending alphabetical order. Return the sorted array.",
      "input_desc": "An array of strings arr, where 1 ≤ len(arr) ≤ 1000. Each string consists of lowercase or uppercase English letters.",
      "output_desc": "A new array representing the finished product after alphabetically sorting using a bubble_sort algorithm",
      "examples": [
        {
          "input": ["banana", "apple", "cherry"],
          "output": ["apple", "banana", "cherry"]
        },
        {
          "input": ["dog", "zebra", "cat", "ant", "hippo"],
          "output": ["ant", "cat", "dog", "hippo", "zebra"]
        }
      ],
      "constraints": [
        "You must implement bubble sort manually; built-in sorting functions like sorted() or .sort() are not allowed.",
        "When sorting make sure to know uppercase letters come before lowercase letters in ASCII order."
      ]
    },
    {
      "id": 4,
      "title": "Bubble Sort Iteration Counter",
      "difficulty": "Medium",
      "description": "Given an array of unsorted integers, implement a bubble sorting algorithm which sorts the array from lowest to highest. Instead of returning the sorted array, count the number of iterations taken to fully sort the array. An iteration is defined as one complete traversal of the array (from the first element to the last) where neighboring elements may be swapped.",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 1000).",
      "output_desc": "An integer representing the number of iterations taken to complete the bubble_sort process",
      "examples": [
        {
          "input": [6, 3, 2, 5, 9],
          "output": 3
        },
        {
          "input": [75, 89, 35, 12, 9, 100],
          "output": 5
        }
      ],
      "constraints": [
        "You must write bubble sort yourself; you cannot use built-in sorting functions like sorted() or .sort().",
        "If an iteration makes no swaps, count that as the last run-through, since the array is already sorted, and return the full count."
      ]
    },
    {
      "id": 5,
      "title": "Custom Bubble Sort",
      "difficulty": "Hard",
      "description": "Given an array of integers, implement a bubble sort algorithm with a single constraint. You can only swap neighboring elements just like a normal bubble sort algorithm; however, the left element has to be even. Return the sorted array according to this rule. If the array cannot be fully sorted due to the constraint, return the partially sorted array.",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 1000).",
      "output_desc": "An array of integers representing the array sorted as much as possible under the constraint.",
      "examples": [
        {
          "input": [4, 3, 2, 1, 9],
          "output": [3, 1, 4, 2, 9]
        },
        {
          "input": [68, 11, 46, 35, 28, 51],
          "output": [11, 35, 28, 46, 51, 68]
        }
      ],
      "constraints": [
        "You must implement bubble sort manually; built-in sorting functions like sorted() or .sort() are not allowed.",
        "Only swap neighboring elements if the left element is even.",
        "Stop iterating early if no swaps are possible in a full iteration."
      ]
    }
  ],
  "merge_sort": [
    {
      "id": 1,
      "title": "Merge Two Sorted Arrays",
      "difficulty": "Easy",
      "description": "Given two sorted arrays, merge them into one single sorted array in ascending order.",
      "input_desc": "Two arrays of numbers, arr1 and arr2, each sorted in ascending order. (1 ≤ len(arr1), len(arr2) ≤ 1000)",
      "output_desc": "A new array containing all elements from arr1 and arr2 in ascending order.",
      "examples": [
        {
          "input": [[1, 3, 5], [2, 4, 6]],
          "output": [1, 2, 3, 4, 5, 6]
        },
        {
          "input": [[10, 20], [5, 15, 25]],
          "output": [5, 10, 15, 20, 25]
        }
      ],
      "constraints": [
        "You must implement the merge process manually; using built-in sorting functions like sorted() or .sort() are not permitted",
        "The inputs are guaranteed to be sorted arrays"
      ]
    },
    {
      "id": 2,
      "title": "Recursive Maximum of an Array",
      "difficulty": "Easy",
      "description": "Given an array of integers, find the maximum value within the array using recursion. Loops and built-in functions like max() are not permitted.",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 1000).",
      "output_desc": "A single integer which represents the largest number in the given array",
      "examples": [
        {
          "input": [3, 1, 7, 4],
          "output": 7
        },
        {
          "input": [10, 2, 5, 8, 6],
          "output": 10
        }
      ],
      "constraints": [
        "You must implement the search process using recursion",
        "Using built-in functions like max() or loops are not permitted"
      ]
    },
    {
      "id": 3,
      "title": "Merge Sort Basic Algorithm",
      "difficulty": "Medium",
      "description": "Given an array of unsorted numbers, implement a basic merge sorting algorithm which takes that input and puts the integers in ascending order using the merge sort algorithm.",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 1000).",
      "output_desc": "A new array of numbers sorted from lowest to highest using merge sort",
      "examples": [
        {
          "input": [8, 3, 1, 7, 0, 10, 2],
          "output": [0, 1, 2, 3, 7, 8, 10]
        },
        {
          "input": [15, 9, 27, 6, 12],
          "output": [6, 9, 12, 15, 27]
        }
      ],
      "constraints": [
        "The sorting must be done using merge sort. Other sorting implementations will not suffice",
        "Built-in sorting functions like sorted() or .sort() are not allowed.",
        "Your solution must use a recursive divide-and-conquer approach"
      ]
    },
    {
      "id": 4,
      "title": "Count Inversions using Merge Sort",
      "difficulty": "Medium",
      "description": "Using elements of the Merge Sort algorithm, count the number of inversions found in the given array after recursively splitting it into halves. An inversion is defined as a pair of elements (arr[i], arr[j]) such that i < j and arr[i] > arr[j].",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 1000).",
      "output_desc": "An integer representing the total number of inversions in the array.",
      "examples": [
        {
          "input": [2, 4, 1, 3, 5],
          "output": 3
        },
        {
          "input": [5, 4, 3, 2, 1],
          "output": 10
        }
      ],
      "constraints": [
        "You may use recursion and the Merge Sort concept but do not implement the entire sort",
        "Aim for O(n log n) complexity using the merge idea.",
        "Built-in sorting functions like sorted() or .sort() are not allowed.",
        "Resource: https://www.geeksforgeeks.org/dsa/inversion-count-in-array-using-merge-sort/"
      ]
    },
    {
      "id": 5,
      "title": "Counting Reverse Pairs",
      "difficulty": "Hard",
      "description": "Given an array of integers, count the number of reverse pairs in the given array. A reverse pair is defined as a pair (i, j) where i < j and arr[i] > 2 * arr[j]. Implement a solution using a modified Merge Sort algorithm.",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 100000).",
      "output_desc": "An integer representing the total number of reverse pairs in the array.",
      "examples": [
        {
          "input": [1, 3, 2, 3, 1],
          "output": 2,
          "explanation": "The reverse pairs are (1, 4) and (3, 4)."
        },
        {
          "input": [2, 4, 3, 5, 1],
          "output": 3,
          "explanation": "The reverse pairs are (1, 4), (2, 4), and (3, 4)."
        }
      ],
      "constraints": [
        "You may use recursion and the Merge Sort concept but do not implement the entire sort",
        "Aim for O(n log n) complexity using the merge idea.",
        "Built-in sorting functions like sorted() or .sort() are not allowed.",
        "Only pairs where i < j are considered."
      ]
    }
  ],
  "selection_sort": [
    {
      "id": 1,
      "title": "Find the Minimum Index",
      "difficulty": "Easy",
      "description": "Given an array of unsorted integers, find the index of the smallest element in the array. Using built-in functions like min() is not permitted",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 100000).",
      "output_desc": "An integer representing the index of the smallest element in the array. If there are multiple occurrences of the minimum, return the first index.",
      "examples": [
        {
          "input": [5, 2, 9, 1, 5, 6],
          "output": 3
        },
        {
          "input": [10, 7, 8, 3, 2, 1],
          "output": 5
        }
      ],
      "constraints": [
        "You must find the minimum element manually; built-in functions like min() are not allowed."
      ]
    },
    {
      "id": 2,
      "title": "Selection Sort Basic Algorithm",
      "difficulty": "Easy",
      "description": "Given an array of unsorted numbers, sort the array in ascending order using the selection sort algorithm.",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 100000).",
      "output_desc": "A new array of numbers sorted from lowest to highest using selection sort.",
      "examples": [
        {
          "input": [5, 2, 9, 1, 5, 6],
          "output": [1, 2, 5, 5, 6, 9]
        },
        {
          "input": [10, 7, 8, 3, 2, 1],
          "output": [1, 2, 3, 7, 8, 10]
        }
      ],
      "constraints": [
        "You must implement selection sort manually; built-in sorting functions like sorted() or .sort() are not allowed.",
        "You must repeatedly find the minimum element and move it to the correct position."
      ]
    },
    {
      "id": 3,
      "title": "Custom Selection Sort Comparison",
      "difficulty": "Medium",
      "description": "Given an array of integers, sort the array in ascending order using selection sort, but with a custom comparison rule. Even numbers should come before odd numbers. Within each group of numbers, maintain ascending order. You must implement this using selection sort manually; built-in sorting functions are not allowed.",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 100000).",
      "output_desc": "A new array of numbers sorted according to the custom rule.",
      "examples": [
        {
          "input": [5, 2, 9, 1, 4, 6],
          "output": [2, 4, 6, 1, 5, 9]
        },
        {
          "input": [10, 7, 8, 3, 2, 1],
          "output": [2, 8, 10, 1, 3, 7]
        }
      ],
      "constraints": [
        "You must implement selection sort manually; built-in sorting functions like sorted() or .sort() are not allowed.",
        "Even numbers always precede odd numbers.",
        "Maintain ascending order within the even and odd groups."
      ]
    },
    {
      "id": 4,
      "title": "Selection Sort Students by Score",
      "difficulty": "Hard",
      "description": "Given a list of student records, each containing a name and a score, sort the list in descending order of scores using selection sort. If two students have the same score, maintain their original relative order. Built-in sorting functions are not allowed.",
      "input_desc": "An array of objects, where each object has 'name' (string) and 'score' (integer). The array length is 1 ≤ len(arr) ≤ 1000.",
      "output_desc": "A new array of student records sorted in descending order by score.",
      "examples": [
        {
          "input": [
            {"name": "Alice", "score": 85},
            {"name": "Bob", "score": 92},
            {"name": "Charlie", "score": 85}
          ],
          "output": [
            {"name": "Bob", "score": 92},
            {"name": "Alice", "score": 85},
            {"name": "Charlie", "score": 85}
          ]
        },
        {
          "input": [
            {"name": "David", "score": 70},
            {"name": "Eve", "score": 90},
            {"name": "Frank", "score": 80}
          ],
          "output": [
            {"name": "Eve", "score": 90},
            {"name": "Frank", "score": 80},
            {"name": "David", "score": 70}
          ]
        }
      ],
      "constraints": [
        "You must implement selection sort manually; built-in sorting functions like sorted() or .sort() are not allowed.",
        "Sort in descending order by score.",
        "Maintain relative order for students with the same score."
      ]
    }
  ],
  "insertion_sort": [
    {
      "id": 1,
      "title": "Insert Target Value",
      "difficulty": "Easy",
      "description": "Given a sorted array of integers and a target value, insert the given number into the correct postiion in the array and make sure it is still sorted in ascending order.",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 1000) and a target value",
      "output_desc": "A new sorted array with the target value inserted in the correct position.",
      "examples": [
        {
          "input": {
            "arr": [1, 3, 5, 7],
            "target": 4
          },
          "output": [1, 3, 4, 5, 7]
        },
        {
          "input": {
            "arr": [2, 4, 6, 8],
            "target": 10
          },
          "output": [2, 4, 6, 8, 10]
        }
      ],
      "constraints": [
        "You must manually find the correct index to insert the target.",
        "Built-in functions are not allowed"
      ]
    },
    {
      "id": 2,
      "title": "Insertion Sort Basic Algorithm",
      "difficulty": "Easy",
      "description": "Given an array of unsorted numbers, implement the insertion sort algorithm to sort the array in ascending order.",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 1000).",
      "output_desc": "A new array of numbers sorted from lowest to highest using insertion sort",
      "examples": [
        {
          "input": [8, 3, 1, 12, 6],
          "output": [1, 3, 6, 8, 12]
        },
        {
          "input": [21, 76, 14, 53, 6, 89],
          "output": [6, 14, 21, 53, 76, 89]
        }
      ],
      "constraints": [
        "You must implement insertion sort manually. Built-in sorting functions like sorted() or .sort() are not allowed.",
        "The algorithm should run in O(n^2) time in the worst case."
      ]
    },
    {
      "id": 3,
      "title": "Count Number of Insertion shifts",
      "difficulty": "Medium",
      "description": "Given an array of integers, implement insertion sort. Instead of returning the sorted array, count how many times the key element moves to the left during the sorting process.",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 1000).",
      "output_desc": "An integer representing the total number of insertion shifts performed by the insertion sort algorithm.",
      "examples": [
        {
          "input": [6, 3, 2, 5, 9],
          "output": 4,
          "explanation": "Key = 3 moves left 1 (swap with 6), Key = 2 moves left 2 (swap with 6 and 3), Key = 5 moves left 1 (swap with 6), Key = 9 moves left 0. Total left moves = 1 + 2 + 1 + 0 = 4."
          
        },
        {
          "input": [4, 3, 2, 1],
          "output": 6,
          "explanation": "Key = 3 moves left 1 (swap with 4), Key = 2 moves left 2 (swap with 4 and 3), Key = 1 moves left 3 (swap with 4, 3, 2). Total left moves = 1 + 2 + 3 = 6."
        }
      ],
      "constraints": [
        "You must implement insertion sort manually. Built-in sorting functions like sorted() or .sort() are not allowed.",
        "Count only the moves of the key element to the left, not the shifts of other elements."
      ]
    },
    {
      "id": 4,
      "title": "Custom Insertion Sort",
      "difficulty": "Hard",
      "description": "Given an array of integers, implement an insertion sort algorithm that sorts the array based on a custom comparator. The comparator will be provided and defines the relative order of any two elements. You must first define the comparator function according to the rules described, and then perform the insertion sort using this comparator.",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 1000). The comparator function is not provided; the user must define it based on the rules described for each example.",
      "output_desc": "A new array of numbers sorted according to the user-defined comparator using insertion sort.",
      "examples": [
        {
          "input": {
          "arr": [5, 2, 9, 1, 4],
          "comparator_description": "Odd numbers should come before even numbers. Within odd and even groups, numbers are sorted in ascending order."
          },
          "output": [1, 5, 9, 2, 4],
          "explanation": "The user-defined comparator checks whether a number is odd or even and uses ascending order within each group. Insertion sort moves elements left until the comparator condition is satisfied."
        },
        {
          "input": {
          "arr": [10, 3, 6, 7, 2],
          "comparator_description": "Numbers are ordered by their remainder modulo 3 (smaller remainders come first). If two numbers have the same remainder, sort them in ascending order."
          },
          "output": [3, 6, 7, 10, 2],
          "explanation": "The comparator function is defined to compare numbers based on their modulo 3 remainder, then ascending order for ties. Insertion sort uses this comparator to place each element correctly."
        }
      ],
      "constraints": [
        "You must implement insertion sort manually. Built-in sorting functions like sorted() or .sort() are not allowed.",
        "You must define the comparator function according to the description for each case.",
        "he algorithm must use your comparator to determine correct insertion positions."
      ]
    }
  ],
  "quick_sort": [
    {
      "id": 1,
      "title": "Partitioned Array around Pivot",
      "difficulty": "Easy",
      "description": "Given an array of integers and a pivot index, rearrange the array so that all elements less than the pivot value come before it, all elements greater than the pivot come after it, and the pivot is in its correct final position. The order of elements within the partitions does not matter. This problem is purely to understand how the partition is created",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 1000) and an integer pivot_index (0 ≤ pivot_index < len(arr)).",
      "output_desc": "A new array where the pivot is in its final position, all elements less than it are to the left, and all elements greater are to the right.",
      "examples": [
        {
          "input": {
            "arr": [8, 3, 1, 7, 0, 10, 2],
            "pivot_index": 1
          },
          "output": [1, 2, 0, 3, 8, 10, 7],
          "explanation": "Pivot value is 3. Elements less than 3 (1, 0, 2) are on the left, elements greater than 3 (8, 7, 10) are on the right, and pivot 3 is in its correct position."
        },
        {
          "input": {
            "arr": [5, 2, 9, 1, 5, 6],
            "pivot_index": 0
          },
          "output": [2, 1, 5, 5, 9, 6],
          "explanation": "Pivot value is 5. Elements less than 5 (2, 1) are on the left, elements greater than 5 (9, 6) are on the right, and pivot 5 is in its correct position."
        }
      ],
      "constraints": [
        "You must implement the partition manually. Built-in sorting functions like sorted() or .sort() are not permitted.",
        "The pivot must end up in its final position as it would in Quick Sort.",
        "The relative order within the partitions does not matter."
      ]
    },
    {
      "id": 2,
      "title": "Quick Sort Basic Algorithm",
      "difficulty": "Easy",
      "description": "Given an array of unsorted numbers, implement a basic Quick Sort sorting algorithm which takes that input and orders the numbers from lowest to highest using that implementation",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 1000).",
      "output_desc": "A new array of numbers sorted from lowest to highest using quick sort",
      "examples": [
        {
          "input": [8, 3, 1, 7, 0, 10, 2],
          "output": [0, 1, 2, 3, 7, 8, 10]
        },
        {
          "input": [15, 9, 27, 6, 12],
          "output": [6, 9, 12, 15, 27]
        }
      ],
      "constraints": [
        "You must implement Quick Sort manually. Built-in sorting functions like sorted() or .sort() are not allowed.",
        "You must use the divide-and-conquer approach. Select a pivot, partition, and recursively sort the partitions."
      ]
    },
    {
      "id": 3,
      "title": "Quick Sort Subarray Partition Count",
      "difficulty": "Medium",
      "description": "Given an array of integers, implement a Quick Sorrt algorithm that recursively partitions the array around a pivot. Instead of returning the sorted array, count the total number of subarrays created during the recursive partitioning process. Count all subarrays generated including single-element subarrays.",
      "input_desc": "An array of numbers arr (1 ≤ len(arr) ≤ 1000).",
      "output_desc": "An integer representing the total number of subarrays created during all recursive partitioning steps.",
      "examples": [
        {
          "input": [8, 3, 1, 7, 0, 10, 2],
          "output": 13
        },
        {
          "input": [5, 2, 9, 1, 5, 6],
          "output": 11
        }
      ],
      "constraints": [
        "You must implement Quick Sort partitioning manually. Built-in sorting functions like sorted() or .sort() are not allowed.",
        "You may choose any element as the pivot for each recursive call.",
        "You don't have to sort the array completely. Only count subarrays generated during partitioning."
      ]
    },
    {
      "id": 4,
      "title": "Dutch National Flag Problem",
      "difficulty": "Medium",
      "description": "Given an array containing only 0s, 1s, and 2s, sort the array in place so that all 0s come first, then all 1s, and then all 2s. Use a three-way partitioning algorithm similar to the one used in quick sort. Swap elements to ensure 0s are on the left, 2s on the right, and 1s in the middle, iterating until mid > high.",
      "input_desc": "An array of integers arr where each element is 0, 1, or 2. (1 ≤ len(arr) ≤ 1000)",
      "output_desc": "The sorted array in-place with all 0s, then 1s, then 2s.",
      "examples": [
        {
          "input": [2, 0, 1, 2, 1, 0],
          "output": [0, 0, 1, 1, 2, 2]
        },
        {
          "input": [0, 2, 1, 0, 1, 2, 0],
          "output": [0, 0, 0, 1, 1, 2, 2]
        }
      ],
      "constraints": [
        "You must implement the three-way partitioning manually. Built-in sorting functions like sorted() or .sort() are not allowed.",
        "The solution should run in O(n) time and O(1) extra space."
      ]
    },
    {
      "id": 5,
      "title": "Quick Sort with Custom Pivot Rule",
      "difficulty": "Hard",
      "description": "Given an array of integers and a custom pivot selection rule, sort the array using a quick sort algorithm. The pivot selection rule is that the pivot is the median of the first, middle, and last elements of the current subarray. You must implement the quick sort algorithm manually and respect the pivot selection rule at every recursive step.",
      "input_desc": "An array of integers arr (1 ≤ len(arr) ≤ 1000).",
      "output_desc": "A new array of integers sorted in ascending order using the quick sort algorithm with the custom pivot rule.",
      "examples": [
        {
          "input": [8, 3, 1, 7, 0, 10, 2],
          "output": [0, 1, 2, 3, 7, 8, 10],
          "explanation": "At each recursive step, choose the pivot as the median of the first, middle, and last element of the subarray. Partition the subarray around this pivot, then recursively quick sort the left and right partitions."
        },
        {
          "input": [15, 9, 27, 6, 12],
          "output": [6, 9, 12, 15, 27],
          "explanation": "The median-of-three pivot selection ensures better partitioning than just taking the first or last element. After partitioning, recursively apply quick sort on the subarrays."
        }
      ],
      "constraints": [
        "You must implement quick sort manually. Built-in sorting functions like sorted() or .sort() are not allowed.",
        "At each recursive step, select the pivot as the median of the first, middle, and last elements of the current subarray.",
        "Your solution should aim for O(n log n) average time complexity.",
      ]
    }
  ]
}
